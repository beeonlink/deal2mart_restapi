"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMarkdownFileSystem = exports.generateMarkdown = exports.generate = void 0;
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const gt_1 = __importDefault(require("semver/functions/gt"));
const utils_1 = require("./utils");
/**
 * Get the documentation generator
 *
 * @param options Documentation generator parameters
 * @returns The single or multi file EJS compiler, ready for usage
 */
const generate = async (options) => {
    // const { apiData, projectData, ejsCompiler } = await loadApiDocProject({ apiDocPath, template, prepend })
    // Define template data
    let apiByGroupAndName;
    // Group apiDoc data by group and name
    apiByGroupAndName = (0, utils_1.unique)(Object.values(options.apiDocApiData).map(x => x.group))
        .reduce((acc, cur) => {
        if (options.apiDocApiData.find(x => x.group === cur))
            acc.push({ name: cur, subs: [] });
        return acc;
    }, [])
        .map((g) => {
        options.apiDocApiData.forEach(x => x.group === g.name && g.subs.push(x));
        return g;
    })
        .map((g) => {
        g.subs = Object.values(g.subs.reduce((acc, cur) => {
            if (!acc[cur.title] || (0, gt_1.default)(cur.version, acc[cur.title].version))
                acc[cur.title] = cur;
            return acc;
        }, {}));
        return g;
    });
    // Sort entries by group name and title ascending
    apiByGroupAndName = apiByGroupAndName.sort((a, b) => a.name.localeCompare(b.name));
    apiByGroupAndName.forEach(x => x.subs.sort((a, b) => a.title.localeCompare(b.title)));
    // Order using the project order setting
    if (options.apiDocProjectData.order) {
        // Lowercased project order setting array
        const orderLowerCase = options.apiDocProjectData.order.map((x) => x.toLowerCase());
        // Filter items in/not in the project order setting array
        const inOrderArr = [];
        const notInOrderArr = [];
        apiByGroupAndName.forEach(x => orderLowerCase.indexOf(x.name.toLowerCase()) === -1 ? notInOrderArr.push(x) : inOrderArr.push(x));
        // Sorted, with the ones not in the project order setting array appended to it
        apiByGroupAndName = [
            ...inOrderArr.sort((a, b) => {
                const aIndex = orderLowerCase.indexOf(a.name.toLowerCase());
                const bIndex = orderLowerCase.indexOf(b.name.toLowerCase());
                if (aIndex === -1 && bIndex === -1)
                    return 0;
                return aIndex > bIndex ? 1 : -1;
            }),
            ...notInOrderArr
        ];
    }
    // This is the config passed to the template
    const templateConfig = {
        // Every functions in `utils_template.js` are passed to the EJS compiler
        ...utils_1.templateUtils,
        project: options.apiDocProjectData,
        header: options.header,
        footer: options.footer,
        prepend: options.prepend
    };
    return !options.multi
        ? [{ name: 'main', content: await options.ejsCompiler({ ...templateConfig, data: apiByGroupAndName }) }]
        : await Promise.all(apiByGroupAndName.map(async (x) => ({
            name: x.name,
            content: await options.ejsCompiler({ ...templateConfig, data: [x] })
        })));
};
exports.generate = generate;
/**
 * Generate mardown documentation.
 *
 * @param options Generator configuration
 * @returns Generated documentation
 */
const generateMarkdown = async (options) => (0, exports.generate)({ ...options, ejsCompiler: await (0, utils_1.loadTemplate)(options.template, false) });
exports.generateMarkdown = generateMarkdown;
/**
 * Generate mardown documentation and create output file(s).
 *
 * @param options Generator configuration
 * @returns Generated documentation
 * @throws Some CLI command parameters are missing or invalid
 */
const generateMarkdownFileSystem = async (options) => {
    // Check the input path exists
    if (!options.input)
        throw new Error('`cli.input` is required but was not provided.');
    if (!(await (0, utils_1.pathExists)(options.input)))
        throw new Error(`The \`cli.input\` path does not exist or is not readable. Path: ${options.input}`);
    // Check the output path exists (only parent directory if unique file)
    if (!options.output)
        throw new Error('`cli.output` is required but was not provided.');
    // Recursively create directory arborescence if cli option is true
    if (options.createPath)
        await (0, utils_1.mkdirp)(options.output.toLowerCase().endsWith('.md') ? path_1.default.dirname(options.output) : options.output);
    const outputPath = options.multi ? options.output : path_1.default.parse(path_1.default.resolve('.', options.output)).dir;
    if (!(await (0, utils_1.pathExists)(outputPath)))
        throw new Error(`The \`cli.output\` path does not exist or is not readable. Path: ${outputPath}`);
    const { apiDocProjectData, apiDocApiData } = (0, utils_1.createDocOrThrow)(options);
    // Check header, footer and prepend file path exist
    options.header = await (0, utils_1.loadFromCliParamOrApiDocProject)('header', options.header, apiDocProjectData);
    options.footer = await (0, utils_1.loadFromCliParamOrApiDocProject)('footer', options.footer, apiDocProjectData);
    options.prepend = await (0, utils_1.loadFromCliParamOrApiDocProject)('prepend', options.prepend, apiDocProjectData);
    // Generate the actual documentation
    const documentation = await (0, exports.generate)({
        ...options,
        apiDocProjectData,
        apiDocApiData,
        ejsCompiler: await (0, utils_1.loadTemplate)(options.template)
    });
    // Create the output files
    if (!options.multi) {
        // Single file documentation generation
        const singleDoc = documentation[0].content;
        await promises_1.default.writeFile(options.output, singleDoc);
        return [{ outputFile: options.output, content: singleDoc }];
    }
    // Multi file documentation generation
    return Promise.all(documentation.map(async (aDoc) => {
        const filePath = path_1.default.resolve(outputPath, `${aDoc.name}.md`);
        await promises_1.default.writeFile(filePath, aDoc.content);
        return { outputFile: filePath, content: aDoc.content };
    }));
};
exports.generateMarkdownFileSystem = generateMarkdownFileSystem;
